#!/usr/bin/env perl
use 5.14.1;
use Dancer qw/:syntax/;
use FindBin;
use Cwd qw/realpath/;
use lib "$FindBin::Bin/../lib";
use Dancer::Plugin::CouchDB;
use Dancer::Plugin::Email;
use Biopay::Cardlock;
use Biopay::Member;
use Biopay::Transaction;
use Biopay::PaymentProcessor;
use Biopay::Command;
use Biopay::Prices;
use Biopay::Receipt;
use AnyEvent;
use Getopt::Long;
use List::Util qw/sum/;
use Try::Tiny;

my %opts;
GetOptions( \%opts,
    'no-cardlock',
) or usage();

$| = 1; # auto-flush STDOUT

Dancer::Config::setting('appdir',realpath("$FindBin::Bin/.."));
Dancer::Config::setting('views',realpath("$FindBin::Bin/../views"));
Dancer::Config::load();

my $couch = couchdb() or die "Couldn't load couch!";
debug "Loading latest fuel price ...\n";
my $price = Biopay::Prices->new->fuel_price;
my $cardlock = Biopay::Cardlock->new( fetch_price_cb => sub { $price } );
my $processor = Biopay::PaymentProcessor->new;

# Desired behaviour for the cardlock connector
# * Check the pump every 10s
# * Check the couch for jobs every 1 minute
# * Check for updated prices every 10 minutes
# * Send the admin stats once per day

my $main_loop = AnyEvent->condvar;
my $cardlock_timer = AnyEvent->timer(
    after => 0.5, interval => 10,
    cb    => \&check_cardlock,
);
my $job_timer = AnyEvent->timer(
    after => 1.0, interval => 60,
    cb    => \&check_for_jobs,
);
my $price_timer = AnyEvent->timer(
    after => 0.001, interval => 600,
    cb    => sub {
        Biopay::Prices->new->fuel_price(
            sub {
                $price = shift;
                debug "Latest fuel price: $price";
            },
        );
    },
);
my $txn_timer = AnyEvent->timer(
    after => 2.0, interval => 300,
    cb => \&check_for_unpaid_txns,
);
my $sigint = AnyEvent->signal(
    signal => "INT",
    cb => sub {
        $main_loop->send;
    },
);

$main_loop->recv; # Main event loop
print "Exiting Connector.\n";
exit;

my %seen_txns; # These may have 0 Litres
my %ok_txns;
sub check_cardlock {
    return if $opts{'no-cardlock'};
    print 'T';
    my $records = $cardlock->recent_transactions;
    for my $txn (@$records) {
        my $id = $txn->{_id};
        autovivify_member($txn->{member_id});
        debug "Attempting to save $txn->{as_string} to the couch\n" unless $seen_txns{$id}++;
        next if $ok_txns{$id};
        $couch->save_doc($txn)->cb(
            sub {
                my $cv = shift;
                eval { $cv->recv };
                if ($@) {
                    if ($@ =~ m/^409/) {
                        double_check_transaction($txn);
                        return;
                    }
                    debug "Failed to save $id to the couch: $@";
                }
                else {
                    debug "Saved transaction $txn->{as_string}";
                }
            }
        );
        $ok_txns{$id}++ if $txn->{litres} > 0;
    }
}

sub double_check_transaction {
    my $txn = shift;
    $couch->open_doc($txn->{_id})->cb( sub {
            my $cv = shift;
            my $doc = $cv->recv;
            if ($doc->{litres} != $txn->{litres}) {
                debug "  Fixing $txn->{_id} - litres: $doc->{litres} vs $txn->{litres}.";
                $txn->{_rev} = $doc->{_rev};
                $couch->save_doc($txn)->cb( sub {
                        my $cv = shift;
                        eval { $cv->recv };
                        debug $@ if $@;
                    }
                );
            }
            else {
                debug "  $txn->{_id} is already correctly in the couch.";
            }
        }
    );
}

sub check_for_unpaid_txns {
    print 'T';
    Biopay::Transaction->All_unpaid(
        sub {
            my $txns = shift;
            my %member;
            for my $txn (@$txns) {
                push @{ $member{$txn->member_id} }, $txn;
            }

            for my $mid (keys %member) {
                my $txns = $member{$mid};
                print "Unpaid txns for $mid: "
                    . join(', ', map { $_->txn_id } @$txns ), "\n";
                Biopay::Member->By_id($mid, sub {
                        my $member = shift;
                        if (my $hash = $member->payment_hash) {
                            process_transactions($member, $txns);
                        }
                        else {
                            print "Member $mid has no payment details.\n";
                        }
                    },
                );
            }
        }
    );
}

sub process_transactions {
    my $member = shift;
    my $txns   = shift;
    return unless @$txns;
    print "Processing transactions for " . $member->name . " ...\n";
    my $total = sum map { $_->price } @$txns;

    my $order_num = @$txns > 1 
        ? sprintf("%d-txns-%d", length(@$txns), time)
        : "txn-" . $txns->[0]->txn_id;
    try {
        $processor->process(
            order_num => $order_num,
            amount => $total,
            hash => $member->payment_hash,
        );
        for my $txn (@$txns) {
            $txn->paid(1);
            $txn->save( sub {
                    debug "Saved " . $txn->id . " to the couch";
                }
            );
        }
        Biopay::Receipt->new(
            member_id => $member->id,
            member => $member,
            txns => $txns,
        )->send;
    }
    catch {
        my $err = $_;
        error $err;

        email {
            to => config->{sysadmin_email},
            from => config->{email_from},
            subject => "Error processing payment $order_num",
            message => $err,
        };
    }

}

sub check_for_jobs {
    print 'J';
    Biopay::Command->Run_jobs( \&handle_job );
}

sub handle_job {
    my $job = shift;
    debug "* Found job of type $job->{command} ...\n";
    my $member_id = $job->args->{member_id};
    return undef unless $member_id;
    Biopay::Member->By_id($member_id, sub {
        my $member = shift;
        my $mid = $member->id;
        given ($job->{command}) {
            when ('freeze') {
                my $pin = $cardlock->fetch_PIN($mid);
                $cardlock->set_PIN($mid, 0);
                $member->PIN($pin);
                $member->save(sub {
                    debug "Saved " . $member->id . " to the couch";
                });
                debug "Froze account of member $mid";
            }
            when ('unfreeze') {
                if ($member->PIN) {
                    $cardlock->set_PIN($mid, $member->PIN);
                    $member->PIN(undef);
                    $member->save(sub {
                        debug "Saved " . $member->id . " to the couch";
                    });
                    debug "Restored frozen account of member $mid";
                }
                else {
                    debug "Cannot un-freeze account, no PIN stored for $mid";
                }
            }
            when ('change_PIN') {
                $cardlock->set_PIN($mid, $job->args->{new_PIN});
                debug "Changed PIN for $mid";
            }
            when ('send-receipt') {
                debug "Sending receipt to $mid (" . $member->name . ")";
                # Shell out so we can avoid AE-style programming of the
                # receipt code
                system($^X, "$FindBin::Bin/send-receipt", $job->_id)
                    and die "Could not send receipt for job " . $job->_id;
            }
            default {
                debug "Skipping unknown command: '$job->{command}'\n";
                return;
            }
        }
        $couch->remove_doc($job)->cb(
            sub {
                my $cv = shift;
                $cv->recv;
                debug "Removed job " . $job->_id . " from the couch";
            }
        );
        }
    );
}

my %seen_members;
sub autovivify_member {
    my $member_id = shift;
    return if $seen_members{$member_id}++;
    my $member = Biopay::Member->Create(
        member_id => $member_id,
        success_cb => sub {
            debug "Saved member $member_id in the couch\n";
        },
        error_cb => sub { },
    );
}

sub usage {
    die <<EOT;
USAGE: $0 [--no-cardlock]

 --no-cardlock  - do not read from the cardlock.
EOT
}
