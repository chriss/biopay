#!/usr/bin/env perl
use 5.14.1;
use Dancer qw/:syntax/;
use FindBin;
use Cwd qw/realpath/;
use lib "$FindBin::Bin/../lib";
use Dancer::Plugin::CouchDB;
use Dancer::Plugin::Email;
use Biopay::Cardlock;
use Biopay::Member;
use Biopay::PotentialMember;
use Biopay::Transaction;
use Biopay::PaymentProcessor;
use Biopay::Command;
use Biopay::Prices;
use Biopay::EmailReceipt;
use Biopay::Receipt;
use Biopay::Util qw/email_admin email_board random_pin host/;
use AnyEvent;
use List::Util qw/sum/;
use Try::Tiny;
use Data::Dumper;

$| = 1; # auto-flush STDOUT

# Load appdir and templates
Dancer::Config::setting('appdir',realpath("$FindBin::Bin/.."));
Dancer::Config::setting('views',realpath("$FindBin::Bin/../views"));
Dancer::Config::load();

my $couch = couchdb();
unless ($couch) {
    email_admin("Couldn't connect to the couch!");
    exit -1;
}

# Desired behaviour for the cardlock connector
# * Check the pump every 10s
# * Check the couch for cardlock jobs every 1 minute
# * Check for updated prices every 10 minutes
# * Check for unpaid transactions every 30 seconds
# * Send the admin stats once per day

my $prices = Biopay::Prices->new;
my $fuel_price = $prices->fuel_price;
my $membership_price = $prices->annual_membership_price;
my $signup_price     = $prices->signup_price;
my $cardlock = Biopay::Cardlock->new( fetch_price_cb => sub { $fuel_price } );
my $processor = Biopay::PaymentProcessor->new;

my $main_loop = AnyEvent->condvar;
my $cardlock_timer = AnyEvent->timer(
    after => 0.5, interval => 10,
    cb    => \&check_cardlock,
);
my $job_timer = AnyEvent->timer(
    after => 1.0, interval => 30,
    cb    => \&check_for_jobs,
);
my $price_timer = AnyEvent->timer(
    after => 0.001, interval => 600,
    cb    => sub {
        Biopay::Prices->new->fuel_price(
            sub {
                $fuel_price = shift;
                print " (F${fuel_price}) ";
            },
        );
    },
);
my $txn_timer = AnyEvent->timer(
    after => 2.0, interval => 30,
    cb => \&check_for_unpaid_txns,
);
my $sigint = AnyEvent->signal(
    signal => "INT",
    cb => sub { $main_loop->send },
);
my $sigterm = AnyEvent->signal(
    signal => "TERM",
    cb => sub { print "$0 shutting down.\n"; $main_loop->send },
);
my $stdin; $stdin = AnyEvent->io(
    fh => *STDIN,
    poll => 'r',
    cb => sub {
        my $key = <STDIN>;
        unless (defined $key) {
            $stdin = undef;
            return;
        }
        chomp $key;
        given ($key) {
            when (m/^X(\d+)/) {
                $cardlock->set_mark($1) if $1;
            }
        }
    },
);


try {
    $main_loop->recv; # Main event loop
}
catch {
    (my $first_line = $_) =~ s/\n.+//s;
    email_admin(
        "Un-caught cardlock error: $first_line",
        "Not sure what happened: $_",
    );
};
print "Exiting Connector.\n";
exit;

my %txn_start;
sub check_cardlock {
    return unless $cardlock->exists;
    print 'C';
    my $records = $cardlock->recent_transactions;
    for my $txn_hash (@$records) {
        my $id = $txn_hash->{_id};
        autovivify_member($txn_hash->{member_id});

        # It may exist already, so we should expect this to fail
        $couch->save_doc($txn_hash)->cb(
            sub {
                my $cv = shift;
                try { $cv->recv }
                catch {
                    return double_check_transaction($txn_hash) if $_ =~ m/^409/;
                    email_admin( "Failed to save txn $id", $_ );
                }
            }
        );
    }
}

my %double_checked_out;
sub double_check_transaction {
    my $txn = shift;
    my $id  = $txn->{_id};
    return if $double_checked_out{$id};
    print " (DoubleCheck $id) ";

    $couch->open_doc($id)->cb( sub {
            my $cv = shift;
            try {
                my $doc = $cv->recv;
                if ($doc->{litres} != $txn->{litres}) {
                    if ($doc->{paid}) {
                        return email_admin(
                            "Paid transaction had incorrect litres",
                            <<EOT);
It looks like transaction $doc->{_id} has been paid already, but the reading
has changed on the pump.

The pump says: $txn->{litres}L but this transaction was for $doc->{litres}L
EOT
                    }
                    print " (!!Fixing $id: $doc->{litres} => "
                        . "$txn->{litres}!!) ";
                    $txn->{_rev} = $doc->{_rev};
                    $couch->save_doc($txn)->cb( sub {
                            my $cv = shift;
                            try { $cv->recv }
                            catch {
                                delete $double_checked_out{$id};
                                email_admin(
                                    "Failed to update txn $id", <<EOT);
I noticed transaction $id had the wrong litres, but I failed to
update it!

I'm trying to update from $doc->{litres} litres to $txn->{litres} litres.

$_
EOT

                            };
                        }
                    );
                }
                my $txn_age = time() - $txn->{epoch_time};
                if ($txn_age > 60*20) {
                    # This transaction is 20 minutes old,
                    # so we can ass_u_me that it's price
                    # won't change further.
                    $double_checked_out{$id}++;
                }
            }
            catch {
                email_admin("Failed to double check $id", $_);
            };
        }
    );
}

sub check_for_unpaid_txns {
    print 'U';
    Biopay::Transaction->All_unpaid(
        sub {
            my $txns = shift;
            my %member;
            for my $txn (@$txns) {
                push @{ $member{$txn->member_id} }, $txn;
            }

            for my $mid (keys %member) {
                my $txns = $member{$mid};
                Biopay::Member->By_id($mid, sub {
                        my $member = shift;
                        unless ($member) {
                            print " (No member $mid found) ";
                            autovivify_member($mid);
                            return;
                        }
                        if (my $hash = $member->payment_hash) {
                            process_transactions($member, $txns)
                                unless $member->billing_error;
                        }
                        else {
                            print 'u';
                        }
                    },
                );
            }
        }
    );
}

sub process_transactions {
    my $member = shift;
    my $txns   = shift;
    return unless @$txns;
    my $total = sum map { $_->price } @$txns;
    print ' (Bio-' . $member->id . ":\$$total) ";
    my $items = [
        map { { amount => $_->price, type => 'txn', desc => $_->txn_id } }
            @$txns
    ];

    my $order_num = @$txns > 1 
        ? sprintf("%d-txns-%d", length(@$txns), time)
        : "txn-" . $txns->[0]->txn_id;

    my $need_to_renew_membership = $member->membership_is_expired;
    if ($need_to_renew_membership) {
        $total += $membership_price;
        push @$items, {
            amount => $membership_price,
            type   => 'dues',
            desc   => 'Membership Dues',
        };
    }

    my $error = "Order '$order_num' not yet processed.";
    try {
        try {
            $processor->process(
                order_num => $order_num,
                amount => $total,
                hash => $member->payment_hash,
            );
            Biopay::Receipt->Create(
                member_id => $member->id,
                order_num => $order_num,
                amount    => $total,
                items     => $items,
            );


            # Update the member, if necessary
            if ($need_to_renew_membership) {
                $member->renew_membership(
                    success_cb => sub {
                        print ' (Renewed membership for: ' . $member->id . ') ';
                        unfreeze_member($member) if $member->frozen;
                    },
                    error_cb => sub {
                        my $save_err = shift;
                        email_admin("Failed to renew membership",
                            "I tried to renew member " . $member->id
                            . "'s dues, but the save failed: $save_err");
                        unfreeze_member($member) if $member->frozen;
                    },
                );
            }
            else {
                unfreeze_member($member) if $member->frozen;
            }
        }
        catch {
            my $err = $_;
            # There was an error processing payment for this member. Set their
            # billing_error flag, so that we don't retry until it is cleared
            $member->billing_error($err);
            $member->frozen(1);
            cardlock_freeze($member, 0); # Freeze on the cardlock directly
            $member->save(
                success_cb => sub {
                    print ' (Freeze:' . $member->id . ') ';
                },
                error_cb => sub {
                    my $save_err = shift;
                    email_admin("Failed to set billing_error for member",
                        "I tried to mark member " . $member->id . " with a "
                        . "billing error for order '$order_num' but failed."
                        . "\nSave error was: $save_err"
                        . "\nPayment error was: $err");
                },
            );
            $member->send_billing_error_email($err, $total);

            # Re-raise error so that it is reported properly.
            die $err;
        };

        $error = "Order '$order_num' processed but txns not marked as paid.";
        for my $txn (@$txns) {
            print " (Marking " . $txn->id . " as paid) ";
            $txn->paid(1);
            $txn->save(
                error_cb => sub {
                    my $err = shift;
                    email_admin("Failed to mark txn:" . $txn->id . " as paid!",
                        "I was trying to mark it as paid after successfully "
                        . " processing order $order_num for \$$total\n\n$err"
                    );
                }
            );
        }
        $error = "Order '$order_num' processed, txns marked as paid, but "
                . "receipt is not sent.";
            
        Biopay::EmailReceipt->new(
            member_id => $member->id,
            member => $member,
            txns => $txns,
            ($need_to_renew_membership 
                ? (dues => $membership_price) : ())
        )->send;
        print " (Receipt to: " . $member->email . ") " if $member->email;
    }
    catch {
        my $err = $_;
        error $err;

        email_admin("Error processing payment $order_num",
            "Had a problem during payment processing: $error\n\n$err\n\n"
            . "This payment was for member ID " . $member->id
            . " for transactions: " . join(', ', map { $_->id } @$txns)
        );
    }
}

sub unfreeze_member {
    my $member = shift;
    $member->frozen(0);
    cardlock_unfreeze($member, 0); # Un-freeze on the cardlock
    $member->save(
        success_cb => sub {
            print ' (Un-freeze:' . $member->id . ') ';
        },
        error_cb => sub {
            my $err = shift;
            email_admin("Failed to un-freeze member",
                "I tried to un-freeze member " . $member->id
                . " after a successful payment, but saving failed."
                . "\nError was: $err");
        },
    );
}

sub check_for_jobs {
    print 'J';
    Biopay::Command->Run_jobs( \&handle_job );
}

sub handle_job {
    my $job = shift;
    debug "* Found job of type $job->{command} ...\n";

    my $job_runner = sub {
        my $member = shift;
        my $mid = $member ? $member->id : 0;
        print " ($job->{command}$mid) ";
        try {
            given ($job->{command}) {
                when ('freeze')   { cardlock_freeze($member, 1, $job) }
                when ('unfreeze') { cardlock_unfreeze($member, 1, $job) }
                when ('change_PIN') {
                    $cardlock->set_PIN($mid, $job->args->{new_PIN});
                }
                when ('send-receipt') {
                    print " (Receipt to $mid - " . $member->name . ") ";
                    # Shell out so we can avoid AE-style programming of the
                    # receipt code
                    system($^X, "$FindBin::Bin/send-receipt", $job->_id)
                        and die "Could not send receipt for job " . $job->_id;
                }
                when ('register-member') {
                    register_member($member, $job->args->{PIN});
                }
                when ('email-all-members') {
                    email_all_members($job->args);
                }
                when ('send-email') {
                    send_email($job->args->{msg});
                }
                default {
                    debug "Skipping unknown command: '$job->{command}'\n";
                    return;
                }
            }
            $couch->remove_doc($job)->cb(
                sub {
                    my $cv = shift;
                    try { $cv->recv }
                    catch {
                        email_admin("Error removing a $job->{command} job",
                            "Failed to remove $job->{_id}\n\n$_"
                        );
                    };
                }
            );
        }
        catch {
            email_admin("Error running job $job->{command} for Member $mid",
                "Tried to run the job but got error: " . shift
                . "\n\n" . Dumper($job)
            );
        };
    };

    if (my $member_id = $job->args->{member_id}) {
        Biopay::Member->By_id($member_id, $job_runner);
    }
    else {
        $job_runner->();
    }
}

sub email_all_members {
    my $args = shift;
    my $subj = $args->{subj} || die "send_email: subj is not defined!";
    my $body = $args->{body} || die "send_email: body is not defined!";

    Biopay::Member->All(
        sub {
            my $members = shift;
            my %emails = map { $_ => 1 } 
                            grep { defined }
                                map { $_->email }
                                    grep { $_->active }
                                        @$members;
            print " (Sending '$subj' to: ";
            for my $email (keys %emails) {
                email {
                    to => $email,
                    from => config->{email_from},
                    subject => $subj . " - $email",
                    type => 'html',
                    message => $body,
                };
                print "$email ";
            }
            print ") ";
        }
    );
}

sub send_email {
    my $args = shift;
    print " (Sending '$args->{subject}' email to $args->{to}) ";
    email {
        from => config->{email_from},
        %$args,
    };
}

sub register_member {
    my $member = shift;
    my $PIN    = shift;
    my $email = $member->email;

    try {
        print " (Register: $email) ";
        # Process sign-up fee
        my $order_num = 'signup:' . $member->id;
        $processor->process(
            order_num => $order_num,
            amount => $signup_price,
            hash => $member->payment_hash,
        );
        Biopay::Receipt->Create(
            member_id => $member->id,
            order_num => $order_num,
            amount    => $signup_price,
            items     => [
                { amount => $signup_price, type => 'signup', desc => 'Signup' }
            ]
        );
        
        # Activate Cardlock
        $cardlock->set_PIN($member->id, $PIN);
        $member->send_welcome_email($PIN);

        email_board("New member - " . $member->id,
            "Hello Board, we just had a new member join the co-op: "
            . $member->name . ".\n\n"
            . "Details: " . host() . "/members/" . $member->id . "\n");
    };
    catch {
        my $err = "Failed to register new member: $_";
        debug $err;
        email_admin("Error registering new member $email", "Error: $err");
    };
}

sub cardlock_freeze {
    my $member = shift;
    my $save = shift;
    my $job = shift;
    my $mid = $member->id;
    my $pin = $cardlock->fetch_PIN($mid);
    $cardlock->set_PIN($mid, 0);
    unless ($job->args->{forget_pin}) {
        $member->PIN($pin);
        $member->save( error_cb => sub {
                email_admin("Failed to save member PIN after freeze",
                    "I froze member $mid but could not save their PIN "
                    . "($pin) back to the couch.\n\n" . shift) } ) if $save;
    }
}

sub cardlock_unfreeze {
    my $member = shift;
    my $save   = shift;
    my $mid = $member->id;
    if ($member->PIN) {
        $cardlock->set_PIN($mid, $member->PIN);
        $member->PIN(undef);
        $member->save( error_cb => sub {
            email_admin("Failed to clear member PIN after unfreeze",
                "I un-froze member $mid but could not clear their "
                . "PIN.\n\n" . shift) } ) if $save;
    }
    else {
        my $random_pin = random_pin();
        try {
            $cardlock->set_PIN($mid, $random_pin);
            if ($member->email) {
                $member->send_new_pin_email($random_pin);
            }
            else {
                email_admin(
                    "Reset member PIN after un-freeze",
                    "I un-froze member ID " . $member->id . " ("
                    . $member->name . ") but had to make a random PIN.\n"
                    . "I couldn't email them their new PIN.  The new PIN is "
                    . "$random_pin.\n\n"
                    . ($member->phone_num 
                        ? "Their phone number is " . $member->phone_num . "."
                        : "They have no phone number. :(")
                );
            }
        }
        catch {
            email_admin("Failed to send reset PIN email to member",
                "I tried to send an email to member " . $member->id
                . " about their reset PIN to $random_pin, but this failed: $_"
            );
        };
    }
}

my %seen_members;
sub autovivify_member {
    my $member_id = shift;
    return if $seen_members{$member_id}++;
    Biopay::Member->Create(
        member_id => $member_id,
        success_cb => sub {
            try {
                print " (Created member $member_id) ";
            }
            catch {
                print " (Failed to create member $member_id - $_) ";
            }
        },
        error_cb => sub {
            my $err = shift;
            if ($err !~ m/^409/) { #ignore 409 conflicts
                print " (Failed to create member $member_id!!!) ";
            }
        },
    );
}

sub usage {
    die <<EOT;
USAGE: $0 [--no-cardlock]

 --no-cardlock  - do not read from the cardlock.
EOT
}

