#!/usr/bin/env perl
use 5.14.1;
use Dancer qw/:syntax/;
use FindBin;
use Cwd qw/realpath/;
use lib "$FindBin::Bin/../lib";
use Dancer::Plugin::CouchDB;
use Dancer::Plugin::Email;
use Biopay::Cardlock;
use Biopay::Member;
use Biopay::Transaction;
use Biopay::PaymentProcessor;
use Biopay::Command;
use Biopay::Prices;
use Biopay::Receipt;
use Biopay::Util qw/email_admin/;
use AnyEvent;
use List::Util qw/sum/;
use Try::Tiny;

$| = 1; # auto-flush STDOUT

# Load appdir and templates
Dancer::Config::setting('appdir',realpath("$FindBin::Bin/.."));
Dancer::Config::setting('views',realpath("$FindBin::Bin/../views"));
Dancer::Config::load();

my $couch = couchdb();
unless ($couch) {
    email_admin("Couldn't connect to the couch!");
    exit -1;
}

# Desired behaviour for the cardlock connector
# * Check the pump every 10s
# * Check the couch for jobs every 1 minute
# * Check for updated prices every 10 minutes
# * Check for unpaid transactions to be run once per hour
# * Send the admin stats once per day

my $price = Biopay::Prices->new->fuel_price;
my $cardlock = Biopay::Cardlock->new( fetch_price_cb => sub { $price } );
my $processor = Biopay::PaymentProcessor->new;

my $main_loop = AnyEvent->condvar;
my $cardlock_timer = AnyEvent->timer(
    after => 0.5, interval => 10,
    cb    => \&check_cardlock,
);
my $job_timer = AnyEvent->timer(
    after => 1.0, interval => 60,
    cb    => \&check_for_jobs,
);
my $price_timer = AnyEvent->timer(
    after => 0.001, interval => 600,
    cb    => sub {
        Biopay::Prices->new->fuel_price(
            sub {
                $price = shift;
                print " (F${price}) ";
            },
        );
    },
);
my $txn_timer = AnyEvent->timer(
    after => 2.0, interval => 3600,
    cb => \&check_for_unpaid_txns,
);
my $sigint = AnyEvent->signal(
    signal => "INT",
    cb => sub { $main_loop->send },
);
my $stdin = AnyEvent->io(
    fh => *STDIN,
    poll => 'r',
    cb => sub {
        my $key = <STDIN>;
        chomp $key;
        given ($key) {
            when (m/^X(\d+)/) {
                $cardlock->set_mark($1) if $1;
            }
        }
    },
);


$main_loop->recv; # Main event loop
print "Exiting Connector.\n";
exit;

my %txn_start;
sub check_cardlock {
    print 'C';
    my $records = $cardlock->recent_transactions;
    for my $txn_hash (@$records) {
        my $id = $txn_hash->{_id};
        autovivify_member($txn_hash->{member_id});

        # It may exist already, so we should expect this to fail
        $couch->save_doc($txn_hash)->cb(
            sub {
                my $cv = shift;
                try {
                    $cv->recv
                }
                catch {
                    return double_check_transaction($txn_hash) if $_ =~ m/^409/;
                    email_admin( "Failed to save txn $id", $_ );
                }
            }
        );
    }
}

my %double_checked_out;
sub double_check_transaction {
    my $txn = shift;
    my $id  = $txn->{_id};
    return if $double_checked_out{$id};
    print " (DoubleCheck $id) ";

    $couch->open_doc($id)->cb( sub {
            my $cv = shift;
            try {
                my $doc = $cv->recv;
                if ($doc->{litres} != $txn->{litres}) {
                    if ($doc->{paid}) {
                        return email_admin(
                            "Paid transaction had incorrect litres",
                            <<EOT);
It looks like transaction $doc->{_id} has been paid already, but the reading
has changed on the pump.

The pump says: $txn->{litres}L but this transaction was for $doc->{litres}L
EOT
                    }
                    print " (!!Fixing $id: $doc->{litres} => "
                        . "$txn->{litres}!!) ";
                    $txn->{_rev} = $doc->{_rev};
                    $couch->save_doc($txn)->cb( sub {
                            my $cv = shift;
                            try {
                                $cv->recv;
                            }
                            catch {
                                delete $double_checked_out{$id};
                                email_admin(
                                    "Failed to update txn $id", <<EOT);
I noticed transaction $id had the wrong litres, but I failed to
update it!

I'm trying to update from $doc->{litres} litres to $txn->{litres} litres.

$_
EOT

                            };
                        }
                    );
                }
                my $txn_age = time() - $txn->{epoch_time};
                if ($txn_age > 60*20) {
                    # This transaction is 20 minutes old,
                    # so we can ass_u_me that it's price
                    # won't change further.
                    $double_checked_out{$id}++;
                }
            }
            catch {
                email_admin("Failed to double check $id", $_);
            };
        }
    );
}

sub check_for_unpaid_txns {
    print 'U';
    Biopay::Transaction->All_unpaid(
        sub {
            my $txns = shift;
            my %member;
            for my $txn (@$txns) {
                push @{ $member{$txn->member_id} }, $txn;
            }

            for my $mid (keys %member) {
                my $txns = $member{$mid};
                Biopay::Member->By_id($mid, sub {
                        my $member = shift;
                        if (my $hash = $member->payment_hash) {
                            process_transactions($member, $txns);
                        }
                        else {
                            print 'u';
                        }
                    },
                );
            }
        }
    );
}

sub process_transactions {
    my $member = shift;
    my $txns   = shift;
    return unless @$txns;
    my $total = sum map { $_->price } @$txns;
    print ' (Bio-' . $member->id . ":\$$total) ";

    my $order_num = @$txns > 1 
        ? sprintf("%d-txns-%d", length(@$txns), time)
        : "txn-" . $txns->[0]->txn_id;
    try {
        $processor->process(
            order_num => $order_num,
            amount => $total,
            hash => $member->payment_hash,
        );
        for my $txn (@$txns) {
            $txn->paid(1);
            $txn->save(
                error_cb => sub {
                    my $err = shift;
                    email_admin("Failed to mark txn:" . $txn->id . " as paid!",
                        "I was trying to mark it as paid after successfully "
                        . " processing order $order_num for \$$total\n\n$err"
                    );
                }
            );
        }
        Biopay::Receipt->new(
            member_id => $member->id,
            member => $member,
            txns => $txns,
        )->send;
    }
    catch {
        my $err = $_;
        error $err;

        email_admin("Error processing payment $order_num", $err);
    }

}

sub check_for_jobs {
    print 'J';
    Biopay::Command->Run_jobs( \&handle_job );
}

sub handle_job {
    my $job = shift;
    debug "* Found job of type $job->{command} ...\n";
    my $member_id = $job->args->{member_id};
    return undef unless $member_id;
    Biopay::Member->By_id($member_id, sub {
        my $member = shift;
        my $mid = $member->id;
        print " ($job->{command}$mid) ";
        given ($job->{command}) {
            when ('freeze') {
                my $pin = $cardlock->fetch_PIN($mid);
                $cardlock->set_PIN($mid, 0);
                $member->PIN($pin);
                $member->save( error_cb => sub {
                        email_admin("Failed to save member PIN after freeze",
                            "I froze member $mid but could not save their PIN "
                            . "($pin) back to the couch.\n\n" . shift) } );
            }
            when ('unfreeze') {
                if ($member->PIN) {
                    $cardlock->set_PIN($mid, $member->PIN);
                    $member->PIN(undef);
                    $member->save( error_cb => sub {
                        email_admin("Failed to clear member PIN after unfreeze",
                            "I un-froze member $mid but could not clear their "
                            . "PIN.\n\n" . shift) } );
                }
                else {
                    debug "Cannot un-freeze account, no PIN stored for $mid";
                    email_admin(
                        "Cannot un-freeze member $mid, no PIN is stored!",
                        "You should probably contact " . $member->name
                        . " at " . $member->email . " and get them to reset "
                        . "their PIN.");
                }
            }
            when ('change_PIN') {
                $cardlock->set_PIN($mid, $job->args->{new_PIN});
            }
            when ('send-receipt') {
                debug "Sending receipt to $mid (" . $member->name . ")";
                # Shell out so we can avoid AE-style programming of the
                # receipt code
                system($^X, "$FindBin::Bin/send-receipt", $job->_id)
                    and die "Could not send receipt for job " . $job->_id;
            }
            default {
                debug "Skipping unknown command: '$job->{command}'\n";
                return;
            }
        }
        $couch->remove_doc($job)->cb(
            sub {
                my $cv = shift;
                try { $cv->recv }
                catch {
                    email_admin("Error removing a $job->{command} job",
                        "Failed to remove $job->{_id}\n\n$_"
                    );
                };
            }
        );
        }
    );
}

my %seen_members;
sub autovivify_member {
    my $member_id = shift;
    return if $seen_members{$member_id}++;
    my $member = Biopay::Member->Create(
        member_id => $member_id,
        success_cb => sub {}, # Ignore result
    );
}

sub usage {
    die <<EOT;
USAGE: $0 [--no-cardlock]

 --no-cardlock  - do not read from the cardlock.
EOT
}

# TODO
# * watch for couch changes
